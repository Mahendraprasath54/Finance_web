import { Request, Response, NextFunction } from 'express';
import { User, IUser } from '../models/user.model';
import { ApiError } from '../middleware/errorHandler';
import { Types, isValidObjectId } from 'mongoose';

type UserQuery = {
  status?: 'active' | 'inactive';
  $or?: Array<{
    [key: string]: { $regex: string; $options: string } | string;
  }>;
};

interface PaginationResult<T> {
  success: boolean;
  data: T[];
  pagination: {
    total: number;
    page: number;
    pages: number;
    limit: number;
  };
}

// Helper function to validate user request
function validateUserRequest(req: Request) {
  const errors: { field: string; message: string }[] = [];
  
  if (!req.body.name || typeof req.body.name !== 'string' || req.body.name.trim().length < 2) {
    errors.push({ field: 'name', message: 'Name is required and must be at least 2 characters long' });
  }
  
  if (!req.body.mobileNumber || !/^\d{10}$/.test(req.body.mobileNumber)) {
    errors.push({ field: 'mobileNumber', message: 'Valid 10-digit mobile number is required' });
  }
  
  // Validate schemes
  if (!Array.isArray(req.body.schemes) || req.body.schemes.length === 0) {
    errors.push({ field: 'schemes', message: 'At least one scheme must be selected' });
  } else {
    const validSchemes = ['gold', 'savings', 'furniture'];
    const invalidSchemes = req.body.schemes.filter((s: string) => !validSchemes.includes(s));
    if (invalidSchemes.length > 0) {
      errors.push({ field: 'schemes', message: `Invalid scheme(s) selected: ${invalidSchemes.join(', ')}` });
    }
  }
  
  // Validate permanent address
  const permanentAddress = req.body.permanentAddress;
  if (!permanentAddress || typeof permanentAddress !== 'object') {
    errors.push({ field: 'permanentAddress', message: 'Permanent address is required' });
  } else {
    const requiredAddressFields = ['doorNumber', 'street', 'area', 'localAddress', 'city', 'district', 'state', 'pinCode'];
    for (const field of requiredAddressFields) {
      if (!permanentAddress[field]) {
        errors.push({ field: `permanentAddress.${field}`, message: `${field} is required` });
      }
    }
  }
  
  // Validate temporary address if provided
  if (req.body.temporaryAddress) {
    const tempAddress = req.body.temporaryAddress;
    const requiredAddressFields = ['doorNumber', 'street', 'area', 'localAddress', 'city', 'district', 'state', 'pinCode'];
    for (const field of requiredAddressFields) {
      if (!tempAddress[field]) {
        errors.push({ field: `temporaryAddress.${field}`, message: `Temporary address ${field} is required` });
      }
    }
  }
  
  return errors.length === 0 ? null : errors;
}

// Create a new user
export const createUser = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const validationErrors = validateUserRequest(req);
    if (validationErrors) {
      return next(ApiError.badRequest('Validation failed', validationErrors));
    }

    const userData: Omit<IUser, 'createdAt' | 'updatedAt'> = req.body;
    
    // Check if mobile number already exists
    const existingUser = await User.findOne({ mobileNumber: userData.mobileNumber });

    if (existingUser) {
      return next(ApiError.conflict('User with this mobile number already exists'));
    }

    // Create new user - employeeId will be auto-generated by the pre-save hook
    const newUser = new User({
      ...userData,
      // Remove employeeId if it was provided, as it will be auto-generated
      employeeId: undefined,
      createdAt: new Date(),
      updatedAt: new Date()
    });

    await newUser.save();
    
    res.status(201).json({
      success: true,
      data: newUser.toObject()
    });
  } catch (error) {
    if (error instanceof Error && error.name === 'ValidationError') {
      const validationErrors = Object.values((error as any).errors).map((err: any) => ({
        field: err.path,
        message: err.message
      }));
      return next(ApiError.badRequest('Validation failed', validationErrors));
    }
    next(error);
  }
};

// Get all users with filtering and pagination
export const getUsers = async (req: Request, res: Response, next: NextFunction) => {
  try {
    // Parse and validate query parameters
    const page = Math.max(1, parseInt(req.query.page as string) || 1);
    const limit = Math.min(100, Math.max(1, parseInt(req.query.limit as string) || 10));
    const status = req.query.status as 'active' | 'inactive' | undefined;
    const search = (req.query.search as string)?.trim();
    
    const query: UserQuery = {};
    
    if (status && ['active', 'inactive'].includes(status)) {
      query.status = status;
    }
    
    if (search) {
      query.$or = [
        { name: { $regex: search, $options: 'i' } },
        { mobileNumber: { $regex: search, $options: 'i' } },
        ...(search.match(/^\d+$/) ? [{ employeeId: search }] : []),
        { 'permanentAddress.city': { $regex: search, $options: 'i' } },
        { 'permanentAddress.area': { $regex: search, $options: 'i' } }
      ];
    }
    
    const skip = (page - 1) * limit;
    
    const [users, total] = await Promise.all([
      User.find(query)
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit)
        .lean(),
      User.countDocuments(query)
    ]);
    
    const result: PaginationResult<IUser> = {
      success: true,
      data: users,
      pagination: {
        total,
        page,
        pages: Math.ceil(total / limit) || 1,
        limit
      }
    };
    
    res.json(result);
  } catch (error) {
    next(error);
  }
};

// Get a single user by ID
export const getUserById = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { id } = req.params;
    
    if (!isValidObjectId(id)) {
      return next(ApiError.badRequest('Invalid user ID'));
    }
    
    const user = await User.findById(id).lean();
    
    if (!user) {
      return next(ApiError.notFound('User not found'));
    }
    
    res.json({
      success: true,
      data: user
    });
  } catch (error) {
    next(error);
  }
};

// Update a user
export const updateUser = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { id } = req.params;
    
    if (!isValidObjectId(id)) {
      return next(ApiError.badRequest('Invalid user ID'));
    }
    
    const validationErrors = validateUserRequest(req);
    if (validationErrors) {
      return next(ApiError.badRequest('Validation failed', validationErrors));
    }
    
    const updates = req.body;
    const user = await User.findById(id);
    
    if (!user) {
      return next(ApiError.notFound('User not found'));
    }
    
    // Prevent updating certain fields
    const { mobileNumber, _id, createdAt, ...allowedUpdates } = updates;
    
    // Handle employee ID separately
    if (updates.employeeId && updates.employeeId !== user.employeeId) {
      const existingUser = await User.findOne({ employeeId: updates.employeeId });
      if (existingUser) {
        return next(ApiError.conflict('Employee ID already in use'));
      }
      user.employeeId = updates.employeeId;
    }
    
    // Handle address updates
    if (updates.permanentAddress) {
      user.permanentAddress = {
        ...user.permanentAddress,
        ...updates.permanentAddress
      };
    }
    
    if (updates.temporaryAddress) {
      user.temporaryAddress = {
        ...user.temporaryAddress,
        ...updates.temporaryAddress
      };
    }
    
    // Update other allowed fields
    const { employeeId, permanentAddress, temporaryAddress, ...otherUpdates } = allowedUpdates;
    Object.assign(user, otherUpdates);
    
    user.updatedAt = new Date();
    
    // Validate the updated user document
    await user.validate();
    await user.save();
    
    res.json({
      success: true,
      data: user.toObject()
    });
  } catch (error) {
    if (error instanceof Error && error.name === 'ValidationError') {
      const validationErrors = Object.values((error as any).errors).map((err: any) => ({
        field: err.path,
        message: err.message
      }));
      return next(ApiError.badRequest('Validation failed', validationErrors));
    }
    next(error);
  }
};

// Delete a user
export const deleteUser = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { id } = req.params;
    
    if (!isValidObjectId(id)) {
      return next(ApiError.badRequest('Invalid user ID'));
    }
    
    const user = await User.findByIdAndDelete(id);
    
    if (!user) {
      return next(ApiError.notFound('User not found'));
    }
    
    // TODO: Consider adding logic to handle related records (e.g., daily entries)
    
    res.json({
      success: true,
      message: 'User deleted successfully',
      data: {
        id: user._id,
        name: user.name,
        mobileNumber: user.mobileNumber
      }
    });
  } catch (error) {
    next(error);
  }
};
